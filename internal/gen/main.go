package main

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
	"text/template"
)

func main() {
	t := template.Must(template.New("f").Parse(tpl))

	funcs := []Func{}

	for i := 0; i < 5; i++ {
		for j := 0; j < 3; j++ {
			funcs = append(funcs,
				Func{
					HasContext:  false,
					HasError:    false,
					InputCount:  i,
					OutputCount: j,
				},
			)

			if j > 0 {
				funcs = append(funcs,
					Func{
						HasContext:  false,
						HasError:    true,
						InputCount:  i,
						OutputCount: j,
					},
				)
			}

			if i > 0 && j > 0 {
				funcs = append(funcs,
					Func{
						HasContext:  true,
						HasError:    true,
						InputCount:  i,
						OutputCount: j,
					},
				)
			}
		}
	}

	o, err := os.OpenFile(os.Args[1], os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o644)
	panicOnErr(err)
	defer o.Close()

	panicOnErr(t.Execute(o, funcs))

	panicOnErr(exec.Command("gofmt", "-w", os.Args[1]).Run())
}

type Func struct {
	HasContext  bool
	HasError    bool
	InputCount  int
	OutputCount int
}

func (f Func) NeedsGeneric() bool {
	switch {
	case f.HasContext && f.InputCount > 1:
	case !f.HasContext && f.InputCount > 0:
	case f.HasError && f.OutputCount > 1:
	case !f.HasError && f.OutputCount > 0:
	default:
		return false
	}

	return true
}

func (f Func) TypeParameter() string {
	if !f.NeedsGeneric() {
		return ""
	}

	var params []string

	for i := 0; i < f.InputCount; i++ {
		if i == 0 && f.HasContext {
			continue
		}
		params = append(params, fmt.Sprintf("T%d", i+1))
	}

	for i := 0; i < f.OutputCount; i++ {
		if i == f.OutputCount-1 && f.HasError {
			continue
		}
		params = append(params, fmt.Sprintf("R%d", i+1))
	}

	return fmt.Sprintf("[%s any]", strings.Join(params, ", "))
}

func (f Func) InputVars() string {
	var params []string
	for i := 0; i < f.InputCount; i++ {
		if i == 0 && f.HasContext {
			params = append(params, "ctx")
		} else {
			params = append(params, fmt.Sprintf("t%d", i+1))
		}
	}

	return fmt.Sprintf("(%s)", strings.Join(params, ", "))
}

func (f Func) OutputVars() string {
	var params []string
	for i := 0; i < f.OutputCount; i++ {
		if i == f.OutputCount-1 && f.HasError {
			params = append(params, "err")
		} else {
			params = append(params, fmt.Sprintf("r%d", i+1))
		}
	}

	return strings.Join(params, ", ")
}

func (f Func) Inputs(showVariable bool) string {
	var params []string
	for i := 0; i < f.InputCount; i++ {
		if i == 0 && f.HasContext {
			if showVariable {
				params = append(params, "t1 context.Context")
			} else {
				params = append(params, "context.Context")
			}
		} else {
			if showVariable {
				params = append(params, fmt.Sprintf("t%d T%d", i+1, i+1))
			} else {
				params = append(params, fmt.Sprintf("T%d", i+1))
			}
		}
	}

	return fmt.Sprintf("(%s)", strings.Join(params, ", "))
}

func (f Func) Outputs(showVariable bool) string {
	var params []string
	for i := 0; i < f.OutputCount; i++ {
		if i == f.OutputCount-1 && f.HasError {
			if showVariable {
				params = append(params, "err error")
			} else {
				params = append(params, "error")
			}
		} else {
			if showVariable {
				params = append(params, fmt.Sprintf("r%d R%d", i+1, i+1))
			} else {
				params = append(params, fmt.Sprintf("R%d", i+1))
			}
		}
	}

	if len(params) == 0 {
		return ""
	}

	if len(params) == 1 && !showVariable {
		return strings.Join(params, ", ")
	}

	return fmt.Sprintf("(%s)", strings.Join(params, ", "))
}

func (f Func) Name() string {
	res := "Wrap"
	if f.HasContext {
		res += "C"
	}
	if f.HasError {
		res += "E"
	}
	res += fmt.Sprint(f.InputCount)
	res += fmt.Sprint(f.OutputCount)
	return res
}

const tpl = `// This file is generated by internal/run/internal/gen. DO NOT EDIT!

package run

import "context"
{{ range . }}
// {{ .Name }} wraps a function with {{ .InputCount }} inputs and {{ .OutputCount }} outputs.
func {{ .Name }}{{- .TypeParameter -}}(
	f func{{ .Inputs false }} {{ .Outputs false }}, opts ...Option,
) func{{ .Inputs false }} {{ .Outputs false }} {
	r := newRunner(opts...)
	return func{{ .Inputs true }} {{ .Outputs true }} {
		{{ if .HasContext -}}
		r.ctx = t1
		{{- end }}
		{{ if .HasError }}err = {{ end }}r.run(func({{ if .HasContext }}ctx{{ else }}_{{ end }} context.Context) (err error) {
			{{ if gt .OutputCount 0 -}}
			{{ .OutputVars }} = f{{.InputVars}}
			return {{ if .HasError }}err{{ else }}nil{{ end }}
			{{ else -}}
			f{{.InputVars}}
			return nil
			{{- end }}
		})
		{{ if gt .OutputCount 0 -}}
		return {{ .OutputVars }}
		{{- end }}
	}
}
{{ end }}
`

func panicOnErr(err error) {
	if err != nil {
		panic(err)
	}
}
