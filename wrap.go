// This file is generated by internal/run/internal/gen. DO NOT EDIT!

package run

import "context"

// Wrap00 wraps a function with 0 inputs and 0 outputs.
func Wrap00(
	f func(), opts ...Option,
) func() {
	r := newRunner(opts...)
	return func() {

		r.run(func(_ context.Context) (err error) {
			f()
			return nil
		})

	}
}

// Wrap01 wraps a function with 0 inputs and 1 outputs.
func Wrap01[R1 any](
	f func() R1, opts ...Option,
) func() R1 {
	r := newRunner(opts...)
	return func() (r1 R1) {

		r.run(func(_ context.Context) (err error) {
			r1 = f()
			return nil

		})
		return r1
	}
}

// WrapE01 wraps a function with 0 inputs and 1 outputs.
func WrapE01(
	f func() error, opts ...Option,
) func() error {
	r := newRunner(opts...)
	return func() (err error) {

		err = r.run(func(_ context.Context) (err error) {
			err = f()
			return err

		})
		return err
	}
}

// Wrap02 wraps a function with 0 inputs and 2 outputs.
func Wrap02[R1, R2 any](
	f func() (R1, R2), opts ...Option,
) func() (R1, R2) {
	r := newRunner(opts...)
	return func() (r1 R1, r2 R2) {

		r.run(func(_ context.Context) (err error) {
			r1, r2 = f()
			return nil

		})
		return r1, r2
	}
}

// WrapE02 wraps a function with 0 inputs and 2 outputs.
func WrapE02[R1 any](
	f func() (R1, error), opts ...Option,
) func() (R1, error) {
	r := newRunner(opts...)
	return func() (r1 R1, err error) {

		err = r.run(func(_ context.Context) (err error) {
			r1, err = f()
			return err

		})
		return r1, err
	}
}

// Wrap10 wraps a function with 1 inputs and 0 outputs.
func Wrap10[T1 any](
	f func(T1), opts ...Option,
) func(T1) {
	r := newRunner(opts...)
	return func(t1 T1) {

		r.run(func(_ context.Context) (err error) {
			f(t1)
			return nil
		})

	}
}

// Wrap11 wraps a function with 1 inputs and 1 outputs.
func Wrap11[T1, R1 any](
	f func(T1) R1, opts ...Option,
) func(T1) R1 {
	r := newRunner(opts...)
	return func(t1 T1) (r1 R1) {

		r.run(func(_ context.Context) (err error) {
			r1 = f(t1)
			return nil

		})
		return r1
	}
}

// WrapE11 wraps a function with 1 inputs and 1 outputs.
func WrapE11[T1 any](
	f func(T1) error, opts ...Option,
) func(T1) error {
	r := newRunner(opts...)
	return func(t1 T1) (err error) {

		err = r.run(func(_ context.Context) (err error) {
			err = f(t1)
			return err

		})
		return err
	}
}

// WrapCE11 wraps a function with 1 inputs and 1 outputs.
func WrapCE11(
	f func(context.Context) error, opts ...Option,
) func(context.Context) error {
	r := newRunner(opts...)
	return func(t1 context.Context) (err error) {
		r.ctx = t1
		err = r.run(func(ctx context.Context) (err error) {
			err = f(ctx)
			return err

		})
		return err
	}
}

// Wrap12 wraps a function with 1 inputs and 2 outputs.
func Wrap12[T1, R1, R2 any](
	f func(T1) (R1, R2), opts ...Option,
) func(T1) (R1, R2) {
	r := newRunner(opts...)
	return func(t1 T1) (r1 R1, r2 R2) {

		r.run(func(_ context.Context) (err error) {
			r1, r2 = f(t1)
			return nil

		})
		return r1, r2
	}
}

// WrapE12 wraps a function with 1 inputs and 2 outputs.
func WrapE12[T1, R1 any](
	f func(T1) (R1, error), opts ...Option,
) func(T1) (R1, error) {
	r := newRunner(opts...)
	return func(t1 T1) (r1 R1, err error) {

		err = r.run(func(_ context.Context) (err error) {
			r1, err = f(t1)
			return err

		})
		return r1, err
	}
}

// WrapCE12 wraps a function with 1 inputs and 2 outputs.
func WrapCE12[R1 any](
	f func(context.Context) (R1, error), opts ...Option,
) func(context.Context) (R1, error) {
	r := newRunner(opts...)
	return func(t1 context.Context) (r1 R1, err error) {
		r.ctx = t1
		err = r.run(func(ctx context.Context) (err error) {
			r1, err = f(ctx)
			return err

		})
		return r1, err
	}
}

// Wrap20 wraps a function with 2 inputs and 0 outputs.
func Wrap20[T1, T2 any](
	f func(T1, T2), opts ...Option,
) func(T1, T2) {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2) {

		r.run(func(_ context.Context) (err error) {
			f(t1, t2)
			return nil
		})

	}
}

// Wrap21 wraps a function with 2 inputs and 1 outputs.
func Wrap21[T1, T2, R1 any](
	f func(T1, T2) R1, opts ...Option,
) func(T1, T2) R1 {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2) (r1 R1) {

		r.run(func(_ context.Context) (err error) {
			r1 = f(t1, t2)
			return nil

		})
		return r1
	}
}

// WrapE21 wraps a function with 2 inputs and 1 outputs.
func WrapE21[T1, T2 any](
	f func(T1, T2) error, opts ...Option,
) func(T1, T2) error {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2) (err error) {

		err = r.run(func(_ context.Context) (err error) {
			err = f(t1, t2)
			return err

		})
		return err
	}
}

// WrapCE21 wraps a function with 2 inputs and 1 outputs.
func WrapCE21[T2 any](
	f func(context.Context, T2) error, opts ...Option,
) func(context.Context, T2) error {
	r := newRunner(opts...)
	return func(t1 context.Context, t2 T2) (err error) {
		r.ctx = t1
		err = r.run(func(ctx context.Context) (err error) {
			err = f(ctx, t2)
			return err

		})
		return err
	}
}

// Wrap22 wraps a function with 2 inputs and 2 outputs.
func Wrap22[T1, T2, R1, R2 any](
	f func(T1, T2) (R1, R2), opts ...Option,
) func(T1, T2) (R1, R2) {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2) (r1 R1, r2 R2) {

		r.run(func(_ context.Context) (err error) {
			r1, r2 = f(t1, t2)
			return nil

		})
		return r1, r2
	}
}

// WrapE22 wraps a function with 2 inputs and 2 outputs.
func WrapE22[T1, T2, R1 any](
	f func(T1, T2) (R1, error), opts ...Option,
) func(T1, T2) (R1, error) {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2) (r1 R1, err error) {

		err = r.run(func(_ context.Context) (err error) {
			r1, err = f(t1, t2)
			return err

		})
		return r1, err
	}
}

// WrapCE22 wraps a function with 2 inputs and 2 outputs.
func WrapCE22[T2, R1 any](
	f func(context.Context, T2) (R1, error), opts ...Option,
) func(context.Context, T2) (R1, error) {
	r := newRunner(opts...)
	return func(t1 context.Context, t2 T2) (r1 R1, err error) {
		r.ctx = t1
		err = r.run(func(ctx context.Context) (err error) {
			r1, err = f(ctx, t2)
			return err

		})
		return r1, err
	}
}

// Wrap30 wraps a function with 3 inputs and 0 outputs.
func Wrap30[T1, T2, T3 any](
	f func(T1, T2, T3), opts ...Option,
) func(T1, T2, T3) {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3) {

		r.run(func(_ context.Context) (err error) {
			f(t1, t2, t3)
			return nil
		})

	}
}

// Wrap31 wraps a function with 3 inputs and 1 outputs.
func Wrap31[T1, T2, T3, R1 any](
	f func(T1, T2, T3) R1, opts ...Option,
) func(T1, T2, T3) R1 {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3) (r1 R1) {

		r.run(func(_ context.Context) (err error) {
			r1 = f(t1, t2, t3)
			return nil

		})
		return r1
	}
}

// WrapE31 wraps a function with 3 inputs and 1 outputs.
func WrapE31[T1, T2, T3 any](
	f func(T1, T2, T3) error, opts ...Option,
) func(T1, T2, T3) error {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3) (err error) {

		err = r.run(func(_ context.Context) (err error) {
			err = f(t1, t2, t3)
			return err

		})
		return err
	}
}

// WrapCE31 wraps a function with 3 inputs and 1 outputs.
func WrapCE31[T2, T3 any](
	f func(context.Context, T2, T3) error, opts ...Option,
) func(context.Context, T2, T3) error {
	r := newRunner(opts...)
	return func(t1 context.Context, t2 T2, t3 T3) (err error) {
		r.ctx = t1
		err = r.run(func(ctx context.Context) (err error) {
			err = f(ctx, t2, t3)
			return err

		})
		return err
	}
}

// Wrap32 wraps a function with 3 inputs and 2 outputs.
func Wrap32[T1, T2, T3, R1, R2 any](
	f func(T1, T2, T3) (R1, R2), opts ...Option,
) func(T1, T2, T3) (R1, R2) {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3) (r1 R1, r2 R2) {

		r.run(func(_ context.Context) (err error) {
			r1, r2 = f(t1, t2, t3)
			return nil

		})
		return r1, r2
	}
}

// WrapE32 wraps a function with 3 inputs and 2 outputs.
func WrapE32[T1, T2, T3, R1 any](
	f func(T1, T2, T3) (R1, error), opts ...Option,
) func(T1, T2, T3) (R1, error) {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3) (r1 R1, err error) {

		err = r.run(func(_ context.Context) (err error) {
			r1, err = f(t1, t2, t3)
			return err

		})
		return r1, err
	}
}

// WrapCE32 wraps a function with 3 inputs and 2 outputs.
func WrapCE32[T2, T3, R1 any](
	f func(context.Context, T2, T3) (R1, error), opts ...Option,
) func(context.Context, T2, T3) (R1, error) {
	r := newRunner(opts...)
	return func(t1 context.Context, t2 T2, t3 T3) (r1 R1, err error) {
		r.ctx = t1
		err = r.run(func(ctx context.Context) (err error) {
			r1, err = f(ctx, t2, t3)
			return err

		})
		return r1, err
	}
}

// Wrap40 wraps a function with 4 inputs and 0 outputs.
func Wrap40[T1, T2, T3, T4 any](
	f func(T1, T2, T3, T4), opts ...Option,
) func(T1, T2, T3, T4) {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3, t4 T4) {

		r.run(func(_ context.Context) (err error) {
			f(t1, t2, t3, t4)
			return nil
		})

	}
}

// Wrap41 wraps a function with 4 inputs and 1 outputs.
func Wrap41[T1, T2, T3, T4, R1 any](
	f func(T1, T2, T3, T4) R1, opts ...Option,
) func(T1, T2, T3, T4) R1 {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3, t4 T4) (r1 R1) {

		r.run(func(_ context.Context) (err error) {
			r1 = f(t1, t2, t3, t4)
			return nil

		})
		return r1
	}
}

// WrapE41 wraps a function with 4 inputs and 1 outputs.
func WrapE41[T1, T2, T3, T4 any](
	f func(T1, T2, T3, T4) error, opts ...Option,
) func(T1, T2, T3, T4) error {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3, t4 T4) (err error) {

		err = r.run(func(_ context.Context) (err error) {
			err = f(t1, t2, t3, t4)
			return err

		})
		return err
	}
}

// WrapCE41 wraps a function with 4 inputs and 1 outputs.
func WrapCE41[T2, T3, T4 any](
	f func(context.Context, T2, T3, T4) error, opts ...Option,
) func(context.Context, T2, T3, T4) error {
	r := newRunner(opts...)
	return func(t1 context.Context, t2 T2, t3 T3, t4 T4) (err error) {
		r.ctx = t1
		err = r.run(func(ctx context.Context) (err error) {
			err = f(ctx, t2, t3, t4)
			return err

		})
		return err
	}
}

// Wrap42 wraps a function with 4 inputs and 2 outputs.
func Wrap42[T1, T2, T3, T4, R1, R2 any](
	f func(T1, T2, T3, T4) (R1, R2), opts ...Option,
) func(T1, T2, T3, T4) (R1, R2) {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3, t4 T4) (r1 R1, r2 R2) {

		r.run(func(_ context.Context) (err error) {
			r1, r2 = f(t1, t2, t3, t4)
			return nil

		})
		return r1, r2
	}
}

// WrapE42 wraps a function with 4 inputs and 2 outputs.
func WrapE42[T1, T2, T3, T4, R1 any](
	f func(T1, T2, T3, T4) (R1, error), opts ...Option,
) func(T1, T2, T3, T4) (R1, error) {
	r := newRunner(opts...)
	return func(t1 T1, t2 T2, t3 T3, t4 T4) (r1 R1, err error) {

		err = r.run(func(_ context.Context) (err error) {
			r1, err = f(t1, t2, t3, t4)
			return err

		})
		return r1, err
	}
}

// WrapCE42 wraps a function with 4 inputs and 2 outputs.
func WrapCE42[T2, T3, T4, R1 any](
	f func(context.Context, T2, T3, T4) (R1, error), opts ...Option,
) func(context.Context, T2, T3, T4) (R1, error) {
	r := newRunner(opts...)
	return func(t1 context.Context, t2 T2, t3 T3, t4 T4) (r1 R1, err error) {
		r.ctx = t1
		err = r.run(func(ctx context.Context) (err error) {
			r1, err = f(ctx, t2, t3, t4)
			return err

		})
		return r1, err
	}
}
